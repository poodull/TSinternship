
<!DOCTYPE html>
<html lang="en">
    <div id="target"></div>
	<head>
		<title>three.js webgl - interactive cubes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body onload = "init();" style = "background-color:#000000">
        <script src = 'JS/tween.js'></script>
		<script type = 'text/javascript' src = 'JS/three.js'></script>
		<script type = 'text/javascript' src = "JS/stats.js"></script>
        <script type = 'text/javascript' src = 'JS/Detector.js'></script>
        <script type = 'text/javascript' src = 'JS/OrbitControls.js'></script>
        <script type="x-shader/x-vertex" id="vertexshader">

			attribute float size;
			attribute vec3 customColor;

			varying vec3 vColor;

			void main() {
				vColor = customColor;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">
			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>


		<script>
                
                var geometry,attributes,uniforms;
                //Rendering/drawing variables
                var points = [],plane; //need to change points to key-value pair container
                //Peripheral function variables
                var INTERSECTED, mouse;
                var PARTICLE_SIZE = 20;
                //Flag Variables
                var Pulse, debug,intersects, AspectRatio;
                //Set this to how many points you want
                var particles = 10;
                //Function calls to start up the proccesses.
                init();
                CreateScene();
                animate();
            
            function init()
            {
                //Initialize
                //Check for WebGL Support on browser
                if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

                var container,scene,element,ScreenWidth,ScreenHeight,controls;
                var camera, renderer, radius, camHelper, raycaster;
                var color, colors = [];
                //Geometry variables for the various objects in this space
                //var SignalPointGeometry, SignalPointMaterial, SignalPoint;
                attributes = 
                {
				size:        { type: 'f', value: [] },
				customColor: { type: 'c', value: [] },
                vertexOpacity: {type: 'f', value: []}
                };
                uniforms = 
                {
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "Assets/Images/circle.png" ) }
			     };
                //Check for keypress/mouse events
                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                document.addEventListener( 'keydown', OnKeyDown, false );
                //document.addEventListener( 'mousedown', onDocumentMouseDown, false);
                window.addEventListener('resize',onWindowResize, false);
            }

            //Main animation function
            function CreateScene()
            {
                scene  = new THREE.Scene();
                renderer = new THREE.WebGLRenderer({antialias: false});
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2(), 
                    
                container = document.createElement( 'div' );
                container.style.position = 'relative';
                document.body.appendChild( container );
                ScreenWidth = window.innerWidth;
                ScreenHeight = window.innerHeight;
                
                var shaderMaterial = new THREE.ShaderMaterial( {

                    uniforms:       uniforms,
                    attributes:     attributes,
                    vertexShader:   document.getElementById( 'vertexshader' ).textContent,
                    fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
                    blending:       THREE.AdditiveAlphaBlending,
                    depthTest:      true,
                    depthWrite: false,
                    transparent:    true,
                    polygonOffset: true,
                    polygonOffsetFactor: 1,
                    polygonOffsetUnits: 1,
                    opacity: 0.5,
                    size_attenuation: true

                });
                
                var radius = 200;
                geometry = new THREE.BufferGeometry();
                var positions = new Float32Array( particles * 3 );
                var values_color = new Float32Array( particles * 3 );
                var values_size = new Float32Array( particles );

                var color = new THREE.Color('255,0,0');
                for( var v = 0; v < particles; v++ ) 
                    {
                    values_size[ v ] = PARTICLE_SIZE * 2;
                    positions[ v * 3 + 0 ] = ( Math.random() * 2 - 1 ) * radius;
                    positions[ v * 3 + 1 ] = 1;//( Math.random() * 2 - 1 ) * radius;
                    positions[ v * 3 + 2 ] = ( Math.random() * 2 - 1 ) * radius;
                    //color.setHSL( v / particles, 1.0, 0.5 );

                    values_color[ v * 3 + 0 ] = color.r;
                    values_color[ v * 3 + 1 ] = color.g;
                    values_color[ v * 3 + 2 ] = color.b;
                    //values_color[ v ] = new THREE.Color().setHSL( 0.01 + 0.1 * ( v / particles ), 1.0, 0.3 );
			         }
            //
                geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
                geometry.addAttribute( 'customColor', new THREE.BufferAttribute( values_color, 3 ) );
                geometry.addAttribute( 'size', new THREE.BufferAttribute( values_size, 1 ) );
                particleSystem = new THREE.PointCloud( geometry, shaderMaterial );
                //Create camera
                var AspectRatio = ScreenWidth/ScreenHeight;
                var ViewSize = 900;
                camera = new THREE.PerspectiveCamera( 50, ScreenWidth / ScreenHeight, 1, 4000 );
                camera.position.set( 700, 245, 475 );
                camera.lookAt(new THREE.Vector3(0,0,0) );

                //Set up mouse controls
                controls = new THREE.OrbitControls(camera); 
                controls.zoomSpeed = 2.2;
                controls.dynamicDampingFactor = 0.3;


                //Assigning renderer attributes
                renderer.setClearColor( 0xf0f0f0 );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize(ScreenWidth, ScreenHeight);
                renderer.sortObjects = false;
                renderer.autoclear = false;
                renderer.domElement.style.position = "relative";
                container.appendChild(renderer.domElement);

                //Set up background for 3D space, in this case: a map of the area, will need to add support for multiple maps.
                plane = new THREE.Mesh(
                        new THREE.PlaneBufferGeometry( ScreenWidth, ScreenHeight, 8, 8 ),
                        new THREE.MeshPhongMaterial( 
                            { 
                            map: THREE.ImageUtils.loadTexture('Assets/Images/NewOfficeTS.png'), 
                            color: 0x000000, 
                            opacity: 0.25, 
                            transparent: true,
                            visible: true,
                            frustumCulled: false
                            } ));
                plane.position.y = 0;
                plane.rotation.x = - Math.PI / 2;

                SurfaceLight = new THREE.SpotLight( 0xffffff, 1.5 );
                SurfaceLight.position.set( 0, 500, 2000 );
                SurfaceLight.castShadow = true;
                SurfaceLight.shadowCameraNear = 200;
                SurfaceLight.shadowCameraFar = camera.far;
                SurfaceLight.shadowCameraFov = 50;
                SurfaceLight.shadowBias = -0.00022;
                SurfaceLight.shadowDarkness = 0.5;
                SurfaceLight.shadowMapWidth = 2048;
                SurfaceLight.shadowMapHeight = 2048;

                    //debugging info
                debug = true;
                Pulse = true;
                if (debug)
                {                
                    var hex = 0xff0000;
                    var boundingbox = new THREE.BoundingBoxHelper(plane, hex);
                    boundingbox.update();
                    scene.add(boundingbox);
                    camHelper = new THREE.CameraHelper( camera );
                    // scene.add(camHelper);
                    stats = new Stats();
                    stats.domElement.style.position = 'absolute';
                    stats.domElement.style.top = '0px'
                    container.appendChild(stats.domElement);
                    }
                scene.add( particleSystem );
                camera.add( plane );
                scene.add( SurfaceLight );
                scene.add( camera );
                scene.add( plane );
            }

            //This causes the points to pulse, linear method, need to implement quadratic easing
            function SignalPulse()
            {
                var pos;
                var time = Date.now() * 0.005;
                //particleSystem.rotation.z = 0.01 * time;
                var size = geometry.attributes.size.array;
                    
                for( var i = 0; i < particles; i++ ) {
                    size[ i ] = 10 * ( 1 + Math.sin( 0.1 * i + time ) );
                    
                }
                geometry.attributes.size.needsUpdate = true;
            }
            
            //Find the points that intersect the cursor's position(x,y)
            function ColorParticle()
            {
                particleSystem.geometry.colorsNeedUpdate = true;
                var step = 0;
                if (step % 8 === 0) {
                    for (var i = 0; i < particleSystem.geometry.colors.length; i++) {
                        particleSystem.geometry.colors[i] = new THREE.Color(0x123152 * Math.random() + 1000 );
                    }
                }
                        step++;
            }
            
            //Change size on hover!
            function FindIntersects()
            {
              /*  raycaster.setFromCamera( mouse, camera );

				intersects = raycaster.intersectObject( particleSystem );

				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].index ) {

						attributes.size.value[ INTERSECTED ] = PARTICLE_SIZE*100;

						INTERSECTED = intersects[ 0 ].index;

						attributes.size.value[ INTERSECTED ] = PARTICLE_SIZE * 100;
						attributes.size.needsUpdate = true;

					}

				} else if ( INTERSECTED !== null ) {

					attributes.size.value[ INTERSECTED ] = PARTICLE_SIZE*100;
					attributes.size.needsUpdate = true;
					INTERSECTED = null;

				}*/

            }
             //Key Bindings
            function OnKeyDown( event )
            {
                switch(event.keyCode)
                {

                case 80: // 'P' Key, Toggles Pulse Animation
                Pulse = !Pulse;
                break;
                }
            }
            //Mouse hover
            function onDocumentMouseMove( event )
            {
                event.preventDefault();

                mouse.x = (event.clientX / ScreenWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / ScreenHeight ) * 2 + 1;
            }
            //Mouse press down
            function onDocumentMouseDown( event )
            {
                event.preventDefault();
                mouse.x = (event.clientX / ScreenWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / ScreenHeight ) * 2 + 1;
            }
            //Handles resizing the window, a little buggy at the moment, needs to be fixed.
          
            function onWindowResize() {
                camera.aspect = ScreenWidth / ScreenHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( ScreenWidth, ScreenHeight);
            }
            
            //Main animation function
            function animate() {
                requestAnimationFrame(animate);
                render();

            }
            
            //Update and Draw
            function render()
            {
                SignalPulse();
                camera.lookAt( scene.position );

                //FindIntersects();
                raycaster.setFromCamera( mouse, camera );
				intersects = raycaster.intersectObject( particleSystem );
				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].index ) {
						attributes.size.value[ INTERSECTED ] = PARTICLE_SIZE;
						INTERSECTED = intersects[ 0 ].index;
						attributes.size.value[ INTERSECTED ] = PARTICLE_SIZE * 100;
                        console.log(INTERSECTED);
                        console.log(attributes.size.value[ INTERSECTED ]);
                        attributes.size.needsUpdate = true;

					}

				} else if ( INTERSECTED !== null ) {
					attributes.size.value[ INTERSECTED ] = PARTICLE_SIZE*100;
					attributes.size.needsUpdate = true;
					INTERSECTED = null;
				}
            controls.update();
            renderer.render(scene, camera);
            stats.update();
            }
		</script>
	</body>
</html>